#include <FL/Fl.H>
#include <FL/Fl_Text_Buffer.H>
#include <FL/Fl_Widget.H>
#include "undo.h"
#include "view_fltk.h"
#include "window_fltk.h"
#include <list>
#include <string>
#include <cstring>

#define DV(x)

typedef struct {
	char command;
	int start;
	int end;
	bool seq; // sequency flag
	char *str;
} UndoInfo;

enum {
	INS = 0,
	BS,
	DEL
};

static bool undo_in_progress = false; // for fltk

static Fl_Text_Buffer* text_buffer = NULL;
static EditorView* editor_view = NULL;
static Fl_Widget* undo_w = NULL;
static Fl_Widget* redo_w = NULL;
static std::list<UndoInfo*> undo_list;
static std::list<UndoInfo*> redo_list;
static std::string undo_str;
static UndoInfo *ui_tmp;
static int modified_step;
static unsigned int prev_keyval;
static bool seq_reserve = false;

// *** Added: store MainWindow pointer passed to undo_init() ***
static MainWindow* main_window = NULL;

// Forward declarations
static void undo_flush_temporal_buffer();
static void undo_clear_info_list(std::list<UndoInfo*>& info_list);
static void undo_append_undo_info(char command, int start, int end, char *str);
static void undo_create_undo_info(char command, int start, int end, const char* text);
static bool undo_undo_real();
static bool undo_redo_real();
static void undo_check_modified_step();

// Helper function to count UTF-8 characters (not bytes)
static int utf8_strlen(const char* str) {
	int count = 0;
	while (*str) {
		if ((*str & 0xC0) != 0x80) count++;
		str++;
	}
	return count;
}

// Stubs for functions that need to be re-implemented
static int get_current_keyval() {
	if (editor_view) {
		return editor_view->last_key;
	}
	return 0;
}

static void clear_current_keyval() {
	if (editor_view) {
		editor_view->last_key = 0;
	}
}

static void scroll_to_cursor(Fl_Text_Buffer*, double) { 
	// Implement scroll to cursor if needed
}

static void buffer_modified_cb(int pos, int nInserted, int nDeleted,
                               int nRestyled, const char* deletedText,
                               void* cbArg)
{
    if (undo_in_progress)
        return;

    MainWindow* window = (MainWindow*)cbArg;

    if (nInserted > 0) {
        char* text = text_buffer->text_range(pos, pos + nInserted);
        int char_count = utf8_strlen(text);
        undo_create_undo_info(INS, pos, pos + char_count, text);
        free(text);
    } else if (nDeleted > 0) {
        int keyval = get_current_keyval();
        char command = (keyval == FL_BackSpace) ? BS : DEL;
        int char_count = utf8_strlen(deletedText);
        undo_create_undo_info(command, pos, pos + char_count, deletedText);
    }
}


void undo_init(Fl_Text_Buffer *buffer, void* view, void* window, Fl_Widget* undo_button, Fl_Widget* redo_button)
{
	text_buffer = buffer;
	editor_view = (EditorView*)view;
	undo_w = undo_button;
	redo_w = redo_button;

	// *** Store the MainWindow pointer so other functions can access it ***
	main_window = (MainWindow*)window;
	
	text_buffer->add_modify_callback(buffer_modified_cb, window);
	
	ui_tmp = (UndoInfo*)malloc(sizeof(UndoInfo));
	undo_clear_all();
}

void undo_clear_all()
{
	undo_clear_info_list(undo_list);
	undo_clear_info_list(redo_list);
	undo_reset_modified_step();
	
	if (undo_w) undo_w->deactivate();
	if (redo_w) redo_w->deactivate();

	ui_tmp->command = INS;
	undo_str.clear();
	prev_keyval = 0;
}

void undo_reset_modified_step()
{
	undo_flush_temporal_buffer();
	modified_step = undo_list.size();
DV(printf("undo_reset_modified_step: Reseted modified_step by %d\n", modified_step));
}

static void undo_check_modified_step()
{
	if (!text_buffer) return;
	
	bool flag = (modified_step == (int)undo_list.size());
	// Use stored main_window instead of calling a non-existent buffer method.
	MainWindow* window = main_window;
	if (window) {
		if (window->changed == flag) {
			window->changed = !flag;
		}
	}
}

void undo_set_sequency(bool seq)
{
	if (!undo_list.empty())
		undo_list.back()->seq = seq;
DV(printf("<undo_set_sequency: %d>\n", seq));
}

void undo_set_sequency_reserve()
{
	seq_reserve = true;
}

static void undo_flush_temporal_buffer()
{
    if (undo_str.empty())
        return;

    UndoInfo* ui = (UndoInfo*)malloc(sizeof(UndoInfo));
    ui->command = ui_tmp->command;
    ui->start   = ui_tmp->start;
    ui->end     = ui_tmp->end;
    ui->seq     = false;
    ui->str     = strdup(undo_str.c_str());

    undo_list.push_back(ui);
    undo_str.clear();
}


void undo_undo()
{
	while (undo_undo_real()) {};
}

void undo_redo()
{
	while (undo_redo_real()) {};
}

static bool undo_undo_real()
{
    undo_flush_temporal_buffer();

    if (undo_list.empty())
        return false;

    undo_in_progress = true;

    UndoInfo *ui = undo_list.back();
    undo_list.pop_back();

    switch (ui->command) {
    case INS:
        text_buffer->remove(ui->start, ui->end);
        break;
    default:
        text_buffer->insert(ui->start, ui->str);
        break;
    }

    redo_list.push_back(ui);
    undo_in_progress = false;

    if (undo_list.empty() && undo_w)
        undo_w->deactivate();
    if (redo_w)
        redo_w->activate();

    text_buffer->select(ui->start, ui->start);
    scroll_to_cursor(text_buffer, 0.05);

    undo_check_modified_step();
    return ui->seq;
}



static bool undo_redo_real()
{
    if (redo_list.empty())
        return false;

    undo_in_progress = true;

    UndoInfo *ui = redo_list.back();
    redo_list.pop_back();

    switch (ui->command) {
    case INS:
        text_buffer->insert(ui->start, ui->str);
        break;
    default:
        text_buffer->remove(ui->start, ui->end);
        break;
    }

    undo_list.push_back(ui);
    undo_in_progress = false;

    if (redo_list.empty() && redo_w)
        redo_w->deactivate();
    if (undo_w)
        undo_w->activate();

    text_buffer->select(ui->start, ui->start);
    scroll_to_cursor(text_buffer, 0.05);

    undo_check_modified_step();
    return ui->seq;
}

static void undo_clear_info_list(std::list<UndoInfo*>& info_list)
{
	for (auto const& i : info_list) {
		free(i->str);
		free(i);
	}
	info_list.clear();
}

static void undo_append_undo_info(char command, int start, int end, char *str)
{
	UndoInfo *ui = (UndoInfo*)malloc(sizeof(UndoInfo));

	ui->command = command;
	ui->start = start;
	ui->end = end;
	ui->seq = seq_reserve;
	ui->str = str;

	seq_reserve = false;

	undo_list.push_back(ui);
DV(printf("undo_append_undo_info: %d %s (%d-%d)\n", command, str, start, end));
}

static void undo_create_undo_info(char command, int start, int end, const char* text)
{
	bool seq_flag = false;
	char *str = strdup(text);
	int keyval = get_current_keyval();
	int text_len = utf8_strlen(text);

	if (!undo_str.empty()) {
		if ((text_len == 1) && (command == ui_tmp->command)) {
			switch (keyval) {
			case FL_BackSpace:
				if (end == ui_tmp->start)
					seq_flag = true;
				break;
			case FL_Delete:
				if (start == ui_tmp->start)
					seq_flag = true;
				break;
			case FL_Tab:
			case ' ':
				if (start == ui_tmp->end)
					seq_flag = true;
				break;
			default:
				if (start == ui_tmp->end)
					if (keyval && keyval < 0xF000)
						switch (prev_keyval) {
						case FL_Enter:
						case FL_Tab:
						case ' ':
							break;
						default:
							seq_flag = true;
						}
			}
		}
		if (seq_flag) {
			switch (command) {
			case BS:
				undo_str.insert(0, str);
				ui_tmp->start--;
				break;
			default:
				undo_str.append(str);
				ui_tmp->end++;
			}
			undo_clear_info_list(redo_list);
			prev_keyval = keyval;
			if (undo_w) undo_w->activate();
			if (redo_w) redo_w->deactivate();
			free(str);
			return;
		}
		undo_append_undo_info(ui_tmp->command, ui_tmp->start, ui_tmp->end, strdup(undo_str.c_str()));
		undo_str.clear();
	}

	if (!keyval && prev_keyval)
		undo_set_sequency(true);

	if (text_len == 1 &&
		((keyval && keyval < 0xF000) ||
		  keyval == FL_BackSpace || keyval == FL_Delete || keyval == FL_Tab)) {
		ui_tmp->command = command;
		ui_tmp->start = start;
		ui_tmp->end = end;
		undo_str.clear();
		undo_str.append(str);
	} else {
		undo_append_undo_info(command, start, end, strdup(str));
	}

	undo_clear_info_list(redo_list);
	prev_keyval = keyval;
	clear_current_keyval();
	
	if (undo_w) undo_w->activate();
	if (redo_w) redo_w->deactivate();
	
	free(str);
}
